'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _runParallel = require('run-parallel');

var _runParallel2 = _interopRequireDefault(_runParallel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var CloudinaryStorage = function () {
  function CloudinaryStorage(opts) {
    _classCallCheck(this, CloudinaryStorage);

    if (!opts || !opts.cloudinary) throw new Error('`cloudinary` option required');
    this.cloudinary = opts.cloudinary;

    this.getFilename = this._getParamGetter('filename', undefined, opts);
    this.getFolder = this._getParamGetter('folder', 'string', opts);
    this.getTransformation = this._getParamGetter('transformation', 'object', opts);
    this.getType = this._getParamGetter('type', 'string', opts);
    this.getFormat = this._getParamGetter('format', 'string', opts);
    this.getParams = this._getParamGetter('params', 'object', opts);
    this.getAllowedFormats = this._getParamGetter('allowedFormats', 'object', opts);
  }

  _createClass(CloudinaryStorage, [{
    key: '_getParamGetter',
    value: function _getParamGetter(name, type, opts) {
      var param = void 0;
      if (typeof opts[name] === 'function') {
        param = opts[name];
      } else if (type && _typeof(opts[name]) === type) {
        param = this._staticVal(opts[name]);
      } else if (opts[name] == undefined) {
        param = this._staticVal(undefined);
      } else {
        var errTemp = void 0;
        if (type) {
          errTemp = ', \'undefined\' or \'' + type + '\'';
        } else {
          errTemp = ' or \'undefined\'';
        }
        throw new TypeError('Expected opts.' + name + ' to be of types \'function\'' + errTemp);
      }
      return param;
    }
  }, {
    key: '_handleFile',
    value: function _handleFile(req, file, cb) {
      var _this = this;

      (0, _runParallel2.default)([this.getParams.bind(this, req, file), this.getFolder.bind(this, req, file), this.getFilename.bind(this, req, file), this.getTransformation.bind(this, req, file), this.getType.bind(this, req, file), this.getFormat.bind(this, req, file), this.getAllowedFormats.bind(this, req, file)], function (err, results) {
        var params = results[0] || {
          folder: results[1],
          public_id: results[2],
          transformation: results[3],
          type: results[4],
          format: results[5],
          allowed_formats: results[6]
        };

        var stream = _this.cloudinary.v2.uploader.upload_stream(params, cb);
        file.stream.pipe(stream);
      });
    }
  }, {
    key: '_removeFile',
    value: function _removeFile(req, file, cb) {
      this.cloudinary.v2.uploader.destroy(file.file_id, { invalidate: true }, cb);
    }
  }, {
    key: '_staticVal',
    value: function _staticVal(val) {
      return function (_, __, cb) {
        cb(undefined, val);
      };
    }
  }]);

  return CloudinaryStorage;
}();
// not using 'export default' to allow compatibility with es5 require


module.exports = function (opts) {
  return new CloudinaryStorage(opts);
};